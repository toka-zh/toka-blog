---
draft: true # 是否为草稿
title: CataClysm-DDA在archlinux下无中文的解决方法
date: 2020-04-08 21:29:43
status: public
tags: games cateclysm      #tag
categories: games          #文章分类
cover: https://tokaku-picture.oss-cn-shanghai.aliyuncs.com/20200408212002.png
---
# 表格对比

## 操作系统发展

|                | 优点             | 缺点                 |
| -------------- | ---------------- | -------------------- |
| 单道批处理系统 | 缓解人机速度矛盾 | 资源利用率低         |
| 多道批处理系统 | 资源利用率高     | 不支持人机交互       |
| 分时操作系统   | 提供人机交互     | 不能优先处理紧急任务 |
| 实时操作系统   | 优先处理紧急任务 |                      |



## 进程调度算法

| 调度算法             | 抢占                     | 优点                                                       | 缺点                                                 | 饥饿 |
| -------------------- | ------------------------ | ---------------------------------------------------------- | ---------------------------------------------------- | ---- |
| 先来先服务（FCFS）   | 非抢占式                 | 公平，实现简单                                             | 对短作业不利                                         | 不会 |
| 短作业优先（SJF）    | 默认非抢占式，也有抢占式 | 平均等待时间/平均周转时间最短                              | 对长作业不利，可能导致饥饿，难以做到真正的短作业优先 | 会   |
| 高响应比优先（HRRN） | 非抢占式                 | 等待越久，相应比越来越大，优先度越来越高，避免了长作业饥饿 |                                                      | 不会 |
| 时间片轮转（RR）     | 抢占式                   | 公平，适用于分时系统                                       | 频繁切换造成高开销，不区分优先级                     | 不会 |
| 优先级调度           | 都有                     | 区分优先级，用于实时操作系统                               | 可能导致饥饿                                         | 会   |
| 多级反馈             | 抢占式                   | 平衡优秀666                                                | 一般没有缺点，可能导致饥饿                           | 会   |



## 页面置换算法

| 置换算法                                | 算法规则                                                     | 优缺点                                 |
| --------------------------------------- | ------------------------------------------------------------ | -------------------------------------- |
| 最佳置换（OPT）                         | 优先淘汰长时间内不会被访问的页面                             | 缺页率最小，性能最好，无法实现         |
| 先进先出（FIFO）                        | 优先淘汰最先进入内存的页面                                   | 实现简单，性能很差，可能出现Belady异常 |
| 最近最久未使用（LRU）                   | 优先淘汰最久没有访问的页面                                   | 性能很好，需要硬件支持，算法开销大     |
| 时钟置换  算法（CLOCK）（最近未用算法） | 循环扫描各页面，第一轮淘汰访问位为0的页面，并将扫描过的页面改为1,若第一轮没选中，则进行第二轮扫描 | 算法开销小，性能还不错                 |



# PV操作

P操作：`申请`资源，如果资源不够则阻塞等待

V操作：`释放`资源，并且唤醒阻塞进程



## 互斥

1. 划定临界区
2. 设置互斥信号量mutex（进入临界区的名额）

```c
semaphore mutex=1; //初始化记录性信号量
```



```c
typedef struct{
    int value;			//剩余资源数
    struct process *L;	//等待队列
}semaphore;
```

3. P(mutex)
4. V(mutex)

pv成对出现





##  同步

1. 分析需要同步的步骤
2. 设置同步信号量S，初始为`0`

3. 先V后P

前操作之后V,后操作之前P（前V后P）



# 死锁

## 原因

1. 系统资源的竞争

2. 进程推进顺序非法

3. 信号量使用不当

总的来说就是资源分配不合理

## 必要条件

1. 互斥条件：资源无法共用，需要互斥等待
2. 不可剥夺条件：已占用资源无法被剥夺，只能主动释放
3. 请求和保持条件：保持已占有资源，申请缺少的资源
4. 循环等待条件：每个进程已获得的资源被下一个进程需求，循环等待资源（`循环等待未必死锁，死锁一定有循环等待`）

## 处理策略

1. 预防死锁：破坏死锁的的的四个产生条件
2. 避免死锁：防止系统进入不安全状态（银行家算法）
3. 死锁的检测和接触`允许死锁的发生`，检测死锁，并解除



### 资源分配图：

进程节点： （圆形）对应一个进程

资源节点：（矩形内圆形资源）对应一类资源的数量



进程>资源：进程申请一个资源

资源>进程：已经为进程分配了一个资源